{"version":3,"file":"script.min.js","mappings":"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","sources":["webpack://organick/webpack/bootstrap","webpack://organick/webpack/runtime/global","webpack://organick/./node_modules/jarallax/dist/jarallax.esm.js","webpack://organick/./app/js/modules/cards.js","webpack://organick/./app/js/script.js","webpack://organick/./app/js/modules/jarallax.js","webpack://organick/./app/js/modules/scroll.js","webpack://organick/./app/js/modules/burger.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","/*!\n * Jarallax v2.1.3 (https://github.com/nk-o/jarallax)\n * Copyright 2022 nK <https://nkdev.info>\n * Licensed under MIT (https://github.com/nk-o/jarallax/blob/master/LICENSE)\n */\nvar defaults$1 = {\n  // Base parallax options.\n  type: 'scroll',\n  speed: 0.5,\n  containerClass: 'jarallax-container',\n  imgSrc: null,\n  imgElement: '.jarallax-img',\n  imgSize: 'cover',\n  imgPosition: '50% 50%',\n  imgRepeat: 'no-repeat',\n  keepImg: false,\n  elementInViewport: null,\n  zIndex: -100,\n  disableParallax: false,\n  // Callbacks.\n  onScroll: null,\n  onInit: null,\n  onDestroy: null,\n  onCoverImage: null,\n  // Video options.\n  videoClass: 'jarallax-video',\n  videoSrc: null,\n  videoStartTime: 0,\n  videoEndTime: 0,\n  videoVolume: 0,\n  videoLoop: true,\n  videoPlayOnlyVisible: true,\n  videoLazyLoading: true,\n  disableVideo: false,\n  // Video callbacks.\n  onVideoInsert: null,\n  onVideoWorkerInit: null\n};\n\n/* eslint-disable import/no-mutable-exports */\n/* eslint-disable no-restricted-globals */\nlet win$1;\nif (typeof window !== 'undefined') {\n  win$1 = window;\n} else if (typeof global !== 'undefined') {\n  win$1 = global;\n} else if (typeof self !== 'undefined') {\n  win$1 = self;\n} else {\n  win$1 = {};\n}\nvar global$2 = win$1;\n\n/**\n * Add styles to element.\n *\n * @param {Element} el - element.\n * @param {String|Object} styles - styles list.\n *\n * @returns {Element}\n */\nfunction css(el, styles) {\n  if (typeof styles === 'string') {\n    return global$2.getComputedStyle(el).getPropertyValue(styles);\n  }\n  Object.keys(styles).forEach(key => {\n    el.style[key] = styles[key];\n  });\n  return el;\n}\n\n/**\n * Extend like jQuery.extend\n *\n * @param {Object} out - output object.\n * @param {...any} args - additional objects to extend.\n *\n * @returns {Object}\n */\nfunction extend$1(out, ...args) {\n  out = out || {};\n  Object.keys(args).forEach(i => {\n    if (!args[i]) {\n      return;\n    }\n    Object.keys(args[i]).forEach(key => {\n      out[key] = args[i][key];\n    });\n  });\n  return out;\n}\n\n/**\n * Get all parents of the element.\n *\n * @param {Element} elem - DOM element.\n *\n * @returns {Array}\n */\nfunction getParents(elem) {\n  const parents = [];\n  while (elem.parentElement !== null) {\n    elem = elem.parentElement;\n    if (elem.nodeType === 1) {\n      parents.push(elem);\n    }\n  }\n  return parents;\n}\n\n/**\n * Document ready callback.\n * @param {Function} callback - callback will be fired once Document ready.\n */\nfunction ready(callback) {\n  if (document.readyState === 'complete' || document.readyState === 'interactive') {\n    // Already ready or interactive, execute callback\n    callback();\n  } else {\n    document.addEventListener('DOMContentLoaded', callback, {\n      capture: true,\n      once: true,\n      passive: true\n    });\n  }\n}\n\nconst {\n  navigator: navigator$1\n} = global$2;\nconst mobileAgent = /*#__PURE__*/ /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator$1.userAgent);\nfunction isMobile() {\n  return mobileAgent;\n}\n\nlet wndW;\nlet wndH;\nlet $deviceHelper;\n\n/**\n * The most popular mobile browsers changes height after page scroll and this generates image jumping.\n * We can fix it using this workaround with vh units.\n */\nfunction getDeviceHeight() {\n  if (!$deviceHelper && document.body) {\n    $deviceHelper = document.createElement('div');\n    $deviceHelper.style.cssText = 'position: fixed; top: -9999px; left: 0; height: 100vh; width: 0;';\n    document.body.appendChild($deviceHelper);\n  }\n  return ($deviceHelper ? $deviceHelper.clientHeight : 0) || global$2.innerHeight || document.documentElement.clientHeight;\n}\nfunction updateWindowHeight() {\n  wndW = global$2.innerWidth || document.documentElement.clientWidth;\n  if (isMobile()) {\n    wndH = getDeviceHeight();\n  } else {\n    wndH = global$2.innerHeight || document.documentElement.clientHeight;\n  }\n}\nupdateWindowHeight();\nglobal$2.addEventListener('resize', updateWindowHeight);\nglobal$2.addEventListener('orientationchange', updateWindowHeight);\nglobal$2.addEventListener('load', updateWindowHeight);\nready(() => {\n  updateWindowHeight();\n});\nfunction getWindowSize() {\n  return {\n    width: wndW,\n    height: wndH\n  };\n}\n\n// List with all jarallax instances\n// need to render all in one scroll/resize event.\nconst jarallaxList = [];\nfunction updateParallax() {\n  if (!jarallaxList.length) {\n    return;\n  }\n  const {\n    width: wndW,\n    height: wndH\n  } = getWindowSize();\n  jarallaxList.forEach((data, k) => {\n    const {\n      instance,\n      oldData\n    } = data;\n    if (!instance.isVisible()) {\n      return;\n    }\n    const clientRect = instance.$item.getBoundingClientRect();\n    const newData = {\n      width: clientRect.width,\n      height: clientRect.height,\n      top: clientRect.top,\n      bottom: clientRect.bottom,\n      wndW,\n      wndH\n    };\n    const isResized = !oldData || oldData.wndW !== newData.wndW || oldData.wndH !== newData.wndH || oldData.width !== newData.width || oldData.height !== newData.height;\n    const isScrolled = isResized || !oldData || oldData.top !== newData.top || oldData.bottom !== newData.bottom;\n    jarallaxList[k].oldData = newData;\n    if (isResized) {\n      instance.onResize();\n    }\n    if (isScrolled) {\n      instance.onScroll();\n    }\n  });\n  global$2.requestAnimationFrame(updateParallax);\n}\nconst visibilityObserver = /*#__PURE__*/new global$2.IntersectionObserver(entries => {\n  entries.forEach(entry => {\n    entry.target.jarallax.isElementInViewport = entry.isIntersecting;\n  });\n}, {\n  // We have to start parallax calculation before the block is in view\n  // to prevent possible parallax jumping.\n  rootMargin: '50px'\n});\nfunction addObserver(instance) {\n  jarallaxList.push({\n    instance\n  });\n  if (jarallaxList.length === 1) {\n    global$2.requestAnimationFrame(updateParallax);\n  }\n  visibilityObserver.observe(instance.options.elementInViewport || instance.$item);\n}\nfunction removeObserver(instance) {\n  jarallaxList.forEach((data, key) => {\n    if (data.instance.instanceID === instance.instanceID) {\n      jarallaxList.splice(key, 1);\n    }\n  });\n  visibilityObserver.unobserve(instance.options.elementInViewport || instance.$item);\n}\n\n/* eslint-disable class-methods-use-this */\nconst {\n  navigator\n} = global$2;\nlet instanceID = 0;\n\n// Jarallax class\nclass Jarallax {\n  constructor(item, userOptions) {\n    const self = this;\n    self.instanceID = instanceID;\n    instanceID += 1;\n    self.$item = item;\n    self.defaults = {\n      ...defaults$1\n    };\n\n    // prepare data-options\n    const dataOptions = self.$item.dataset || {};\n    const pureDataOptions = {};\n    Object.keys(dataOptions).forEach(key => {\n      const lowerCaseOption = key.substr(0, 1).toLowerCase() + key.substr(1);\n      if (lowerCaseOption && typeof self.defaults[lowerCaseOption] !== 'undefined') {\n        pureDataOptions[lowerCaseOption] = dataOptions[key];\n      }\n    });\n    self.options = self.extend({}, self.defaults, pureDataOptions, userOptions);\n    self.pureOptions = self.extend({}, self.options);\n\n    // prepare 'true' and 'false' strings to boolean\n    Object.keys(self.options).forEach(key => {\n      if (self.options[key] === 'true') {\n        self.options[key] = true;\n      } else if (self.options[key] === 'false') {\n        self.options[key] = false;\n      }\n    });\n\n    // fix speed option [-1.0, 2.0]\n    self.options.speed = Math.min(2, Math.max(-1, parseFloat(self.options.speed)));\n\n    // prepare disableParallax callback\n    if (typeof self.options.disableParallax === 'string') {\n      self.options.disableParallax = new RegExp(self.options.disableParallax);\n    }\n    if (self.options.disableParallax instanceof RegExp) {\n      const disableParallaxRegexp = self.options.disableParallax;\n      self.options.disableParallax = () => disableParallaxRegexp.test(navigator.userAgent);\n    }\n    if (typeof self.options.disableParallax !== 'function') {\n      self.options.disableParallax = () => false;\n    }\n\n    // prepare disableVideo callback\n    if (typeof self.options.disableVideo === 'string') {\n      self.options.disableVideo = new RegExp(self.options.disableVideo);\n    }\n    if (self.options.disableVideo instanceof RegExp) {\n      const disableVideoRegexp = self.options.disableVideo;\n      self.options.disableVideo = () => disableVideoRegexp.test(navigator.userAgent);\n    }\n    if (typeof self.options.disableVideo !== 'function') {\n      self.options.disableVideo = () => false;\n    }\n\n    // custom element to check if parallax in viewport\n    let elementInVP = self.options.elementInViewport;\n    // get first item from array\n    if (elementInVP && typeof elementInVP === 'object' && typeof elementInVP.length !== 'undefined') {\n      [elementInVP] = elementInVP;\n    }\n    // check if dom element\n    if (!(elementInVP instanceof Element)) {\n      elementInVP = null;\n    }\n    self.options.elementInViewport = elementInVP;\n    self.image = {\n      src: self.options.imgSrc || null,\n      $container: null,\n      useImgTag: false,\n      // 1. Position fixed is needed for the most of browsers because absolute position have glitches\n      // 2. On MacOS with smooth scroll there is a huge lags with absolute position - https://github.com/nk-o/jarallax/issues/75\n      // 3. Previously used 'absolute' for mobile devices. But we re-tested on iPhone 12 and 'fixed' position is working better, then 'absolute', so for now position is always 'fixed'\n      position: 'fixed'\n    };\n    if (self.initImg() && self.canInitParallax()) {\n      self.init();\n    }\n  }\n  css(el, styles) {\n    return css(el, styles);\n  }\n  extend(out, ...args) {\n    return extend$1(out, ...args);\n  }\n\n  // get window size and scroll position. Useful for extensions\n  getWindowData() {\n    const {\n      width,\n      height\n    } = getWindowSize();\n    return {\n      width,\n      height,\n      y: document.documentElement.scrollTop\n    };\n  }\n\n  // Jarallax functions\n  initImg() {\n    const self = this;\n\n    // find image element\n    let $imgElement = self.options.imgElement;\n    if ($imgElement && typeof $imgElement === 'string') {\n      $imgElement = self.$item.querySelector($imgElement);\n    }\n\n    // check if dom element\n    if (!($imgElement instanceof Element)) {\n      if (self.options.imgSrc) {\n        $imgElement = new Image();\n        $imgElement.src = self.options.imgSrc;\n      } else {\n        $imgElement = null;\n      }\n    }\n    if ($imgElement) {\n      if (self.options.keepImg) {\n        self.image.$item = $imgElement.cloneNode(true);\n      } else {\n        self.image.$item = $imgElement;\n        self.image.$itemParent = $imgElement.parentNode;\n      }\n      self.image.useImgTag = true;\n    }\n\n    // true if there is img tag\n    if (self.image.$item) {\n      return true;\n    }\n\n    // get image src\n    if (self.image.src === null) {\n      self.image.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';\n      self.image.bgImage = self.css(self.$item, 'background-image');\n    }\n    return !(!self.image.bgImage || self.image.bgImage === 'none');\n  }\n  canInitParallax() {\n    return !this.options.disableParallax();\n  }\n  init() {\n    const self = this;\n    const containerStyles = {\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      width: '100%',\n      height: '100%',\n      overflow: 'hidden'\n    };\n    let imageStyles = {\n      pointerEvents: 'none',\n      transformStyle: 'preserve-3d',\n      backfaceVisibility: 'hidden'\n    };\n    if (!self.options.keepImg) {\n      // save default user styles\n      const curStyle = self.$item.getAttribute('style');\n      if (curStyle) {\n        self.$item.setAttribute('data-jarallax-original-styles', curStyle);\n      }\n      if (self.image.useImgTag) {\n        const curImgStyle = self.image.$item.getAttribute('style');\n        if (curImgStyle) {\n          self.image.$item.setAttribute('data-jarallax-original-styles', curImgStyle);\n        }\n      }\n    }\n\n    // set relative position and z-index to the parent\n    if (self.css(self.$item, 'position') === 'static') {\n      self.css(self.$item, {\n        position: 'relative'\n      });\n    }\n    if (self.css(self.$item, 'z-index') === 'auto') {\n      self.css(self.$item, {\n        zIndex: 0\n      });\n    }\n\n    // container for parallax image\n    self.image.$container = document.createElement('div');\n    self.css(self.image.$container, containerStyles);\n    self.css(self.image.$container, {\n      'z-index': self.options.zIndex\n    });\n\n    // it will remove some image overlapping\n    // overlapping occur due to an image position fixed inside absolute position element\n    // needed only when background in fixed position\n    if (this.image.position === 'fixed') {\n      self.css(self.image.$container, {\n        '-webkit-clip-path': 'polygon(0 0, 100% 0, 100% 100%, 0 100%)',\n        'clip-path': 'polygon(0 0, 100% 0, 100% 100%, 0 100%)'\n      });\n    }\n\n    // Add container unique ID.\n    self.image.$container.setAttribute('id', `jarallax-container-${self.instanceID}`);\n\n    // Add container class.\n    if (self.options.containerClass) {\n      self.image.$container.setAttribute('class', self.options.containerClass);\n    }\n    self.$item.appendChild(self.image.$container);\n\n    // use img tag\n    if (self.image.useImgTag) {\n      imageStyles = self.extend({\n        'object-fit': self.options.imgSize,\n        'object-position': self.options.imgPosition,\n        'max-width': 'none'\n      }, containerStyles, imageStyles);\n\n      // use div with background image\n    } else {\n      self.image.$item = document.createElement('div');\n      if (self.image.src) {\n        imageStyles = self.extend({\n          'background-position': self.options.imgPosition,\n          'background-size': self.options.imgSize,\n          'background-repeat': self.options.imgRepeat,\n          'background-image': self.image.bgImage || `url(\"${self.image.src}\")`\n        }, containerStyles, imageStyles);\n      }\n    }\n    if (self.options.type === 'opacity' || self.options.type === 'scale' || self.options.type === 'scale-opacity' || self.options.speed === 1) {\n      self.image.position = 'absolute';\n    }\n\n    // 1. Check if one of parents have transform style (without this check, scroll transform will be inverted if used parallax with position fixed)\n    //    discussion - https://github.com/nk-o/jarallax/issues/9\n    // 2. Check if parents have overflow scroll\n    if (self.image.position === 'fixed') {\n      const $parents = getParents(self.$item).filter(el => {\n        const styles = global$2.getComputedStyle(el);\n        const parentTransform = styles['-webkit-transform'] || styles['-moz-transform'] || styles.transform;\n        const overflowRegex = /(auto|scroll)/;\n        return parentTransform && parentTransform !== 'none' || overflowRegex.test(styles.overflow + styles['overflow-y'] + styles['overflow-x']);\n      });\n      self.image.position = $parents.length ? 'absolute' : 'fixed';\n    }\n\n    // add position to parallax block\n    imageStyles.position = self.image.position;\n\n    // insert parallax image\n    self.css(self.image.$item, imageStyles);\n    self.image.$container.appendChild(self.image.$item);\n\n    // set initial position and size\n    self.onResize();\n    self.onScroll(true);\n\n    // call onInit event\n    if (self.options.onInit) {\n      self.options.onInit.call(self);\n    }\n\n    // remove default user background\n    if (self.css(self.$item, 'background-image') !== 'none') {\n      self.css(self.$item, {\n        'background-image': 'none'\n      });\n    }\n    addObserver(self);\n  }\n  destroy() {\n    const self = this;\n    removeObserver(self);\n\n    // return styles on container as before jarallax init\n    const originalStylesTag = self.$item.getAttribute('data-jarallax-original-styles');\n    self.$item.removeAttribute('data-jarallax-original-styles');\n    // null occurs if there is no style tag before jarallax init\n    if (!originalStylesTag) {\n      self.$item.removeAttribute('style');\n    } else {\n      self.$item.setAttribute('style', originalStylesTag);\n    }\n    if (self.image.useImgTag) {\n      // return styles on img tag as before jarallax init\n      const originalStylesImgTag = self.image.$item.getAttribute('data-jarallax-original-styles');\n      self.image.$item.removeAttribute('data-jarallax-original-styles');\n      // null occurs if there is no style tag before jarallax init\n      if (!originalStylesImgTag) {\n        self.image.$item.removeAttribute('style');\n      } else {\n        self.image.$item.setAttribute('style', originalStylesTag);\n      }\n\n      // move img tag to its default position\n      if (self.image.$itemParent) {\n        self.image.$itemParent.appendChild(self.image.$item);\n      }\n    }\n\n    // remove additional dom elements\n    if (self.image.$container) {\n      self.image.$container.parentNode.removeChild(self.image.$container);\n    }\n\n    // call onDestroy event\n    if (self.options.onDestroy) {\n      self.options.onDestroy.call(self);\n    }\n\n    // delete jarallax from item\n    delete self.$item.jarallax;\n  }\n  coverImage() {\n    const self = this;\n    const {\n      height: wndH\n    } = getWindowSize();\n    const rect = self.image.$container.getBoundingClientRect();\n    const contH = rect.height;\n    const {\n      speed\n    } = self.options;\n    const isScroll = self.options.type === 'scroll' || self.options.type === 'scroll-opacity';\n    let scrollDist = 0;\n    let resultH = contH;\n    let resultMT = 0;\n\n    // scroll parallax\n    if (isScroll) {\n      // scroll distance and height for image\n      if (speed < 0) {\n        scrollDist = speed * Math.max(contH, wndH);\n        if (wndH < contH) {\n          scrollDist -= speed * (contH - wndH);\n        }\n      } else {\n        scrollDist = speed * (contH + wndH);\n      }\n\n      // size for scroll parallax\n      if (speed > 1) {\n        resultH = Math.abs(scrollDist - wndH);\n      } else if (speed < 0) {\n        resultH = scrollDist / speed + Math.abs(scrollDist);\n      } else {\n        resultH += (wndH - contH) * (1 - speed);\n      }\n      scrollDist /= 2;\n    }\n\n    // store scroll distance\n    self.parallaxScrollDistance = scrollDist;\n\n    // vertical center\n    if (isScroll) {\n      resultMT = (wndH - resultH) / 2;\n    } else {\n      resultMT = (contH - resultH) / 2;\n    }\n\n    // apply result to item\n    self.css(self.image.$item, {\n      height: `${resultH}px`,\n      marginTop: `${resultMT}px`,\n      left: self.image.position === 'fixed' ? `${rect.left}px` : '0',\n      width: `${rect.width}px`\n    });\n\n    // call onCoverImage event\n    if (self.options.onCoverImage) {\n      self.options.onCoverImage.call(self);\n    }\n\n    // return some useful data. Used in the video cover function\n    return {\n      image: {\n        height: resultH,\n        marginTop: resultMT\n      },\n      container: rect\n    };\n  }\n  isVisible() {\n    return this.isElementInViewport || false;\n  }\n  onScroll(force) {\n    const self = this;\n\n    // stop calculations if item is not in viewport\n    if (!force && !self.isVisible()) {\n      return;\n    }\n    const {\n      height: wndH\n    } = getWindowSize();\n    const rect = self.$item.getBoundingClientRect();\n    const contT = rect.top;\n    const contH = rect.height;\n    const styles = {};\n\n    // calculate parallax helping variables\n    const beforeTop = Math.max(0, contT);\n    const beforeTopEnd = Math.max(0, contH + contT);\n    const afterTop = Math.max(0, -contT);\n    const beforeBottom = Math.max(0, contT + contH - wndH);\n    const beforeBottomEnd = Math.max(0, contH - (contT + contH - wndH));\n    const afterBottom = Math.max(0, -contT + wndH - contH);\n    const fromViewportCenter = 1 - 2 * ((wndH - contT) / (wndH + contH));\n\n    // calculate on how percent of section is visible\n    let visiblePercent = 1;\n    if (contH < wndH) {\n      visiblePercent = 1 - (afterTop || beforeBottom) / contH;\n    } else if (beforeTopEnd <= wndH) {\n      visiblePercent = beforeTopEnd / wndH;\n    } else if (beforeBottomEnd <= wndH) {\n      visiblePercent = beforeBottomEnd / wndH;\n    }\n\n    // opacity\n    if (self.options.type === 'opacity' || self.options.type === 'scale-opacity' || self.options.type === 'scroll-opacity') {\n      styles.transform = 'translate3d(0,0,0)';\n      styles.opacity = visiblePercent;\n    }\n\n    // scale\n    if (self.options.type === 'scale' || self.options.type === 'scale-opacity') {\n      let scale = 1;\n      if (self.options.speed < 0) {\n        scale -= self.options.speed * visiblePercent;\n      } else {\n        scale += self.options.speed * (1 - visiblePercent);\n      }\n      styles.transform = `scale(${scale}) translate3d(0,0,0)`;\n    }\n\n    // scroll\n    if (self.options.type === 'scroll' || self.options.type === 'scroll-opacity') {\n      let positionY = self.parallaxScrollDistance * fromViewportCenter;\n\n      // fix if parallax block in absolute position\n      if (self.image.position === 'absolute') {\n        positionY -= contT;\n      }\n      styles.transform = `translate3d(0,${positionY}px,0)`;\n    }\n    self.css(self.image.$item, styles);\n\n    // call onScroll event\n    if (self.options.onScroll) {\n      self.options.onScroll.call(self, {\n        section: rect,\n        beforeTop,\n        beforeTopEnd,\n        afterTop,\n        beforeBottom,\n        beforeBottomEnd,\n        afterBottom,\n        visiblePercent,\n        fromViewportCenter\n      });\n    }\n  }\n  onResize() {\n    this.coverImage();\n  }\n}\n\n// global definition\nconst jarallax$1 = function (items, options, ...args) {\n  // check for dom element\n  // thanks: http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object\n  if (typeof HTMLElement === 'object' ? items instanceof HTMLElement : items && typeof items === 'object' && items !== null && items.nodeType === 1 && typeof items.nodeName === 'string') {\n    items = [items];\n  }\n  const len = items.length;\n  let k = 0;\n  let ret;\n  for (k; k < len; k += 1) {\n    if (typeof options === 'object' || typeof options === 'undefined') {\n      if (!items[k].jarallax) {\n        items[k].jarallax = new Jarallax(items[k], options);\n      }\n    } else if (items[k].jarallax) {\n      // eslint-disable-next-line prefer-spread\n      ret = items[k].jarallax[options].apply(items[k].jarallax, args);\n    }\n    if (typeof ret !== 'undefined') {\n      return ret;\n    }\n  }\n  return items;\n};\njarallax$1.constructor = Jarallax;\n\n/*!\n * Video Worker v2.1.5 (https://github.com/nk-o/video-worker)\n * Copyright 2022 nK <https://nkdev.info>\n * Licensed under MIT (https://github.com/nk-o/video-worker/blob/master/LICENSE)\n */\n\n/* eslint-disable import/no-mutable-exports */\n/* eslint-disable no-restricted-globals */\nlet win;\nif (typeof window !== 'undefined') {\n  win = window;\n} else if (typeof global !== 'undefined') {\n  win = global;\n} else if (typeof self !== 'undefined') {\n  win = self;\n} else {\n  win = {};\n}\nvar global$1 = win;\n\n// Deferred\n// thanks http://stackoverflow.com/questions/18096715/implement-deferred-object-without-using-jquery\nfunction Deferred() {\n  this.doneCallbacks = [];\n  this.failCallbacks = [];\n}\nDeferred.prototype = {\n  execute(list, args) {\n    let i = list.length;\n    // eslint-disable-next-line no-param-reassign\n    args = Array.prototype.slice.call(args);\n    while (i) {\n      i -= 1;\n      list[i].apply(null, args);\n    }\n  },\n  resolve(...args) {\n    this.execute(this.doneCallbacks, args);\n  },\n  reject(...args) {\n    this.execute(this.failCallbacks, args);\n  },\n  done(callback) {\n    this.doneCallbacks.push(callback);\n  },\n  fail(callback) {\n    this.failCallbacks.push(callback);\n  }\n};\nvar defaults = {\n  autoplay: false,\n  loop: false,\n  mute: false,\n  volume: 100,\n  showControls: true,\n  accessibilityHidden: false,\n  // start / end video time in seconds\n  startTime: 0,\n  endTime: 0\n};\n\n/**\n * Extend like jQuery.extend\n *\n * @param {Object} out - output object.\n * @param {...any} args - additional objects to extend.\n *\n * @returns {Object}\n */\nfunction extend(out, ...args) {\n  out = out || {};\n  Object.keys(args).forEach(i => {\n    if (!args[i]) {\n      return;\n    }\n    Object.keys(args[i]).forEach(key => {\n      out[key] = args[i][key];\n    });\n  });\n  return out;\n}\nlet ID = 0;\nlet YoutubeAPIadded = 0;\nlet VimeoAPIadded = 0;\nlet loadingYoutubePlayer = 0;\nlet loadingVimeoPlayer = 0;\nconst loadingYoutubeDefer = /*#__PURE__*/new Deferred();\nconst loadingVimeoDefer = /*#__PURE__*/new Deferred();\nclass VideoWorker {\n  constructor(url, options) {\n    const self = this;\n    self.url = url;\n    self.options_default = {\n      ...defaults\n    };\n    self.options = extend({}, self.options_default, options);\n\n    // check URL\n    self.videoID = self.parseURL(url);\n\n    // init\n    if (self.videoID) {\n      self.ID = ID;\n      ID += 1;\n      self.loadAPI();\n      self.init();\n    }\n  }\n  parseURL(url) {\n    // parse youtube ID\n    function getYoutubeID(ytUrl) {\n      // eslint-disable-next-line no-useless-escape\n      const regExp = /.*(?:youtu.be\\/|v\\/|u\\/\\w\\/|embed\\/|shorts\\/|watch\\?v=)([^#\\&\\?]*).*/;\n      const match = ytUrl.match(regExp);\n      return match && match[1].length === 11 ? match[1] : false;\n    }\n\n    // parse vimeo ID\n    function getVimeoID(vmUrl) {\n      // eslint-disable-next-line no-useless-escape\n      const regExp = /https?:\\/\\/(?:www\\.|player\\.)?vimeo.com\\/(?:channels\\/(?:\\w+\\/)?|groups\\/([^/]*)\\/videos\\/|album\\/(\\d+)\\/video\\/|video\\/|)(\\d+)(?:$|\\/|\\?)/;\n      const match = vmUrl.match(regExp);\n      return match && match[3] ? match[3] : false;\n    }\n\n    // parse local string\n    function getLocalVideos(locUrl) {\n      // eslint-disable-next-line no-useless-escape\n      const videoFormats = locUrl.split(/,(?=mp4\\:|webm\\:|ogv\\:|ogg\\:)/);\n      const result = {};\n      let ready = 0;\n      videoFormats.forEach(val => {\n        // eslint-disable-next-line no-useless-escape\n        const match = val.match(/^(mp4|webm|ogv|ogg)\\:(.*)/);\n        if (match && match[1] && match[2]) {\n          // eslint-disable-next-line prefer-destructuring\n          result[match[1] === 'ogv' ? 'ogg' : match[1]] = match[2];\n          ready = 1;\n        }\n      });\n      return ready ? result : false;\n    }\n    const Youtube = getYoutubeID(url);\n    const Vimeo = getVimeoID(url);\n    const Local = getLocalVideos(url);\n    if (Youtube) {\n      this.type = 'youtube';\n      return Youtube;\n    }\n    if (Vimeo) {\n      this.type = 'vimeo';\n      return Vimeo;\n    }\n    if (Local) {\n      this.type = 'local';\n      return Local;\n    }\n    return false;\n  }\n  isValid() {\n    return !!this.videoID;\n  }\n\n  // events\n  on(name, callback) {\n    this.userEventsList = this.userEventsList || [];\n\n    // add new callback in events list\n    (this.userEventsList[name] || (this.userEventsList[name] = [])).push(callback);\n  }\n  off(name, callback) {\n    if (!this.userEventsList || !this.userEventsList[name]) {\n      return;\n    }\n    if (!callback) {\n      delete this.userEventsList[name];\n    } else {\n      this.userEventsList[name].forEach((val, key) => {\n        if (val === callback) {\n          this.userEventsList[name][key] = false;\n        }\n      });\n    }\n  }\n  fire(name, ...args) {\n    if (this.userEventsList && typeof this.userEventsList[name] !== 'undefined') {\n      this.userEventsList[name].forEach(val => {\n        // call with all arguments\n        if (val) {\n          val.apply(this, args);\n        }\n      });\n    }\n  }\n  play(start) {\n    const self = this;\n    if (!self.player) {\n      return;\n    }\n    if (self.type === 'youtube' && self.player.playVideo) {\n      if (typeof start !== 'undefined') {\n        self.player.seekTo(start || 0);\n      }\n      if (global$1.YT.PlayerState.PLAYING !== self.player.getPlayerState()) {\n        self.player.playVideo();\n      }\n    }\n    if (self.type === 'vimeo') {\n      if (typeof start !== 'undefined') {\n        self.player.setCurrentTime(start);\n      }\n      self.player.getPaused().then(paused => {\n        if (paused) {\n          self.player.play();\n        }\n      });\n    }\n    if (self.type === 'local') {\n      if (typeof start !== 'undefined') {\n        self.player.currentTime = start;\n      }\n      if (self.player.paused) {\n        self.player.play();\n      }\n    }\n  }\n  pause() {\n    const self = this;\n    if (!self.player) {\n      return;\n    }\n    if (self.type === 'youtube' && self.player.pauseVideo) {\n      if (global$1.YT.PlayerState.PLAYING === self.player.getPlayerState()) {\n        self.player.pauseVideo();\n      }\n    }\n    if (self.type === 'vimeo') {\n      self.player.getPaused().then(paused => {\n        if (!paused) {\n          self.player.pause();\n        }\n      });\n    }\n    if (self.type === 'local') {\n      if (!self.player.paused) {\n        self.player.pause();\n      }\n    }\n  }\n  mute() {\n    const self = this;\n    if (!self.player) {\n      return;\n    }\n    if (self.type === 'youtube' && self.player.mute) {\n      self.player.mute();\n    }\n    if (self.type === 'vimeo' && self.player.setVolume) {\n      self.setVolume(0);\n    }\n    if (self.type === 'local') {\n      self.$video.muted = true;\n    }\n  }\n  unmute() {\n    const self = this;\n    if (!self.player) {\n      return;\n    }\n    if (self.type === 'youtube' && self.player.mute) {\n      self.player.unMute();\n    }\n    if (self.type === 'vimeo' && self.player.setVolume) {\n      // In case the default volume is 0, we have to set 100 when unmute.\n      self.setVolume(self.options.volume || 100);\n    }\n    if (self.type === 'local') {\n      self.$video.muted = false;\n    }\n  }\n  setVolume(volume = false) {\n    const self = this;\n    if (!self.player || typeof volume !== 'number') {\n      return;\n    }\n    if (self.type === 'youtube' && self.player.setVolume) {\n      self.player.setVolume(volume);\n    }\n    if (self.type === 'vimeo' && self.player.setVolume) {\n      self.player.setVolume(volume / 100);\n    }\n    if (self.type === 'local') {\n      self.$video.volume = volume / 100;\n    }\n  }\n  getVolume(callback) {\n    const self = this;\n    if (!self.player) {\n      callback(false);\n      return;\n    }\n    if (self.type === 'youtube' && self.player.getVolume) {\n      callback(self.player.getVolume());\n    }\n    if (self.type === 'vimeo' && self.player.getVolume) {\n      self.player.getVolume().then(volume => {\n        callback(volume * 100);\n      });\n    }\n    if (self.type === 'local') {\n      callback(self.$video.volume * 100);\n    }\n  }\n  getMuted(callback) {\n    const self = this;\n    if (!self.player) {\n      callback(null);\n      return;\n    }\n    if (self.type === 'youtube' && self.player.isMuted) {\n      callback(self.player.isMuted());\n    }\n    if (self.type === 'vimeo' && self.player.getVolume) {\n      self.player.getVolume().then(volume => {\n        callback(!!volume);\n      });\n    }\n    if (self.type === 'local') {\n      callback(self.$video.muted);\n    }\n  }\n  getImageURL(callback) {\n    const self = this;\n    if (self.videoImage) {\n      callback(self.videoImage);\n      return;\n    }\n    if (self.type === 'youtube') {\n      const availableSizes = ['maxresdefault', 'sddefault', 'hqdefault', '0'];\n      let step = 0;\n      const tempImg = new Image();\n      tempImg.onload = function () {\n        // if no thumbnail, youtube add their own image with width = 120px\n        if ((this.naturalWidth || this.width) !== 120 || step === availableSizes.length - 1) {\n          // ok\n          self.videoImage = `https://img.youtube.com/vi/${self.videoID}/${availableSizes[step]}.jpg`;\n          callback(self.videoImage);\n        } else {\n          // try another size\n          step += 1;\n          this.src = `https://img.youtube.com/vi/${self.videoID}/${availableSizes[step]}.jpg`;\n        }\n      };\n      tempImg.src = `https://img.youtube.com/vi/${self.videoID}/${availableSizes[step]}.jpg`;\n    }\n    if (self.type === 'vimeo') {\n      // We should provide width to get HQ thumbnail URL.\n      let width = global$1.innerWidth || 1920;\n      if (global$1.devicePixelRatio) {\n        width *= global$1.devicePixelRatio;\n      }\n      width = Math.min(width, 1920);\n      let request = new XMLHttpRequest();\n      // https://vimeo.com/api/oembed.json?url=https://vimeo.com/235212527\n      request.open('GET', `https://vimeo.com/api/oembed.json?url=${self.url}&width=${width}`, true);\n      request.onreadystatechange = function () {\n        if (this.readyState === 4) {\n          if (this.status >= 200 && this.status < 400) {\n            // Success!\n            const response = JSON.parse(this.responseText);\n            if (response.thumbnail_url) {\n              self.videoImage = response.thumbnail_url;\n              callback(self.videoImage);\n            }\n          }\n        }\n      };\n      request.send();\n      request = null;\n    }\n  }\n\n  // fallback to the old version.\n  getIframe(callback) {\n    this.getVideo(callback);\n  }\n  getVideo(callback) {\n    const self = this;\n\n    // return generated video block\n    if (self.$video) {\n      callback(self.$video);\n      return;\n    }\n\n    // generate new video block\n    self.onAPIready(() => {\n      let hiddenDiv;\n      if (!self.$video) {\n        hiddenDiv = document.createElement('div');\n        hiddenDiv.style.display = 'none';\n      }\n\n      // Youtube\n      if (self.type === 'youtube') {\n        self.playerOptions = {\n          // GDPR Compliance.\n          host: 'https://www.youtube-nocookie.com',\n          videoId: self.videoID,\n          playerVars: {\n            autohide: 1,\n            rel: 0,\n            autoplay: 0,\n            // autoplay enable on mobile devices\n            playsinline: 1\n          }\n        };\n\n        // hide controls\n        if (!self.options.showControls) {\n          self.playerOptions.playerVars.iv_load_policy = 3;\n          self.playerOptions.playerVars.modestbranding = 1;\n          self.playerOptions.playerVars.controls = 0;\n          self.playerOptions.playerVars.showinfo = 0;\n          self.playerOptions.playerVars.disablekb = 1;\n        }\n\n        // events\n        let ytStarted;\n        let ytProgressInterval;\n        self.playerOptions.events = {\n          onReady(e) {\n            // mute\n            if (self.options.mute) {\n              e.target.mute();\n            } else if (typeof self.options.volume === 'number') {\n              e.target.setVolume(self.options.volume);\n            }\n\n            // autoplay\n            if (self.options.autoplay) {\n              self.play(self.options.startTime);\n            }\n            self.fire('ready', e);\n\n            // For seamless loops, set the endTime to 0.1 seconds less than the video's duration\n            // https://github.com/nk-o/video-worker/issues/2\n            if (self.options.loop && !self.options.endTime) {\n              const secondsOffset = 0.1;\n              self.options.endTime = self.player.getDuration() - secondsOffset;\n            }\n\n            // volumechange\n            setInterval(() => {\n              self.getVolume(volume => {\n                if (self.options.volume !== volume) {\n                  self.options.volume = volume;\n                  self.fire('volumechange', e);\n                }\n              });\n            }, 150);\n          },\n          onStateChange(e) {\n            // loop\n            if (self.options.loop && e.data === global$1.YT.PlayerState.ENDED) {\n              self.play(self.options.startTime);\n            }\n            if (!ytStarted && e.data === global$1.YT.PlayerState.PLAYING) {\n              ytStarted = 1;\n              self.fire('started', e);\n            }\n            if (e.data === global$1.YT.PlayerState.PLAYING) {\n              self.fire('play', e);\n            }\n            if (e.data === global$1.YT.PlayerState.PAUSED) {\n              self.fire('pause', e);\n            }\n            if (e.data === global$1.YT.PlayerState.ENDED) {\n              self.fire('ended', e);\n            }\n\n            // progress check\n            if (e.data === global$1.YT.PlayerState.PLAYING) {\n              ytProgressInterval = setInterval(() => {\n                self.fire('timeupdate', e);\n\n                // check for end of video and play again or stop\n                if (self.options.endTime && self.player.getCurrentTime() >= self.options.endTime) {\n                  if (self.options.loop) {\n                    self.play(self.options.startTime);\n                  } else {\n                    self.pause();\n                  }\n                }\n              }, 150);\n            } else {\n              clearInterval(ytProgressInterval);\n            }\n          },\n          onError(e) {\n            self.fire('error', e);\n          }\n        };\n        const firstInit = !self.$video;\n        if (firstInit) {\n          const div = document.createElement('div');\n          div.setAttribute('id', self.playerID);\n          hiddenDiv.appendChild(div);\n          document.body.appendChild(hiddenDiv);\n        }\n        self.player = self.player || new global$1.YT.Player(self.playerID, self.playerOptions);\n        if (firstInit) {\n          self.$video = document.getElementById(self.playerID);\n\n          // add accessibility attributes\n          if (self.options.accessibilityHidden) {\n            self.$video.setAttribute('tabindex', '-1');\n            self.$video.setAttribute('aria-hidden', 'true');\n          }\n\n          // get video width and height\n          self.videoWidth = parseInt(self.$video.getAttribute('width'), 10) || 1280;\n          self.videoHeight = parseInt(self.$video.getAttribute('height'), 10) || 720;\n        }\n      }\n\n      // Vimeo\n      if (self.type === 'vimeo') {\n        self.playerOptions = {\n          // GDPR Compliance.\n          dnt: 1,\n          id: self.videoID,\n          autopause: 0,\n          transparent: 0,\n          autoplay: self.options.autoplay ? 1 : 0,\n          loop: self.options.loop ? 1 : 0,\n          muted: self.options.mute || self.options.volume === 0 ? 1 : 0\n        };\n\n        // hide controls\n        if (!self.options.showControls) {\n          self.playerOptions.controls = 0;\n        }\n\n        // enable background option\n        if (!self.options.showControls && self.options.loop && self.options.autoplay) {\n          self.playerOptions.background = 1;\n        }\n        if (!self.$video) {\n          let playerOptionsString = '';\n          Object.keys(self.playerOptions).forEach(key => {\n            if (playerOptionsString !== '') {\n              playerOptionsString += '&';\n            }\n            playerOptionsString += `${key}=${encodeURIComponent(self.playerOptions[key])}`;\n          });\n\n          // we need to create iframe manually because when we create it using API\n          // js events won't triggers after iframe moved to another place\n          self.$video = document.createElement('iframe');\n          self.$video.setAttribute('id', self.playerID);\n          self.$video.setAttribute('src', `https://player.vimeo.com/video/${self.videoID}?${playerOptionsString}`);\n          self.$video.setAttribute('frameborder', '0');\n          self.$video.setAttribute('mozallowfullscreen', '');\n          self.$video.setAttribute('allowfullscreen', '');\n          self.$video.setAttribute('title', 'Vimeo video player');\n\n          // add accessibility attributes\n          if (self.options.accessibilityHidden) {\n            self.$video.setAttribute('tabindex', '-1');\n            self.$video.setAttribute('aria-hidden', 'true');\n          }\n          hiddenDiv.appendChild(self.$video);\n          document.body.appendChild(hiddenDiv);\n        }\n        self.player = self.player || new global$1.Vimeo.Player(self.$video, self.playerOptions);\n\n        // Since Vimeo removed the `volume` parameter, we have to set it manually.\n        if (!self.options.mute && typeof self.options.volume === 'number') {\n          self.setVolume(self.options.volume);\n        }\n\n        // set current time for autoplay\n        if (self.options.startTime && self.options.autoplay) {\n          self.player.setCurrentTime(self.options.startTime);\n        }\n\n        // get video width and height\n        self.player.getVideoWidth().then(width => {\n          self.videoWidth = width || 1280;\n        });\n        self.player.getVideoHeight().then(height => {\n          self.videoHeight = height || 720;\n        });\n\n        // events\n        let vmStarted;\n        self.player.on('timeupdate', e => {\n          if (!vmStarted) {\n            self.fire('started', e);\n            vmStarted = 1;\n          }\n          self.fire('timeupdate', e);\n\n          // check for end of video and play again or stop\n          if (self.options.endTime) {\n            if (self.options.endTime && e.seconds >= self.options.endTime) {\n              if (self.options.loop) {\n                self.play(self.options.startTime);\n              } else {\n                self.pause();\n              }\n            }\n          }\n        });\n        self.player.on('play', e => {\n          self.fire('play', e);\n\n          // check for the start time and start with it\n          if (self.options.startTime && e.seconds === 0) {\n            self.play(self.options.startTime);\n          }\n        });\n        self.player.on('pause', e => {\n          self.fire('pause', e);\n        });\n        self.player.on('ended', e => {\n          self.fire('ended', e);\n        });\n        self.player.on('loaded', e => {\n          self.fire('ready', e);\n        });\n        self.player.on('volumechange', e => {\n          self.getVolume(volume => {\n            self.options.volume = volume;\n          });\n          self.fire('volumechange', e);\n        });\n        self.player.on('error', e => {\n          self.fire('error', e);\n        });\n      }\n\n      // Local\n      function addSourceToLocal(element, src, type) {\n        const source = document.createElement('source');\n        source.src = src;\n        source.type = type;\n        element.appendChild(source);\n      }\n      if (self.type === 'local') {\n        if (!self.$video) {\n          self.$video = document.createElement('video');\n          self.player = self.$video;\n\n          // show controls\n          if (self.options.showControls) {\n            self.$video.controls = true;\n          }\n\n          // set volume\n          if (typeof self.options.volume === 'number') {\n            self.setVolume(self.options.volume);\n          }\n\n          // mute (it is required to mute after the volume set)\n          if (self.options.mute) {\n            self.mute();\n          }\n\n          // loop\n          if (self.options.loop) {\n            self.$video.loop = true;\n          }\n\n          // autoplay enable on mobile devices\n          self.$video.setAttribute('playsinline', '');\n          self.$video.setAttribute('webkit-playsinline', '');\n\n          // add accessibility attributes\n          if (self.options.accessibilityHidden) {\n            self.$video.setAttribute('tabindex', '-1');\n            self.$video.setAttribute('aria-hidden', 'true');\n          }\n          self.$video.setAttribute('id', self.playerID);\n          hiddenDiv.appendChild(self.$video);\n          document.body.appendChild(hiddenDiv);\n          Object.keys(self.videoID).forEach(key => {\n            addSourceToLocal(self.$video, self.videoID[key], `video/${key}`);\n          });\n        }\n        let locStarted;\n        self.player.addEventListener('playing', e => {\n          if (!locStarted) {\n            self.fire('started', e);\n          }\n          locStarted = 1;\n        });\n        self.player.addEventListener('timeupdate', function (e) {\n          self.fire('timeupdate', e);\n\n          // check for end of video and play again or stop\n          if (self.options.endTime) {\n            if (self.options.endTime && this.currentTime >= self.options.endTime) {\n              if (self.options.loop) {\n                self.play(self.options.startTime);\n              } else {\n                self.pause();\n              }\n            }\n          }\n        });\n        self.player.addEventListener('play', e => {\n          self.fire('play', e);\n        });\n        self.player.addEventListener('pause', e => {\n          self.fire('pause', e);\n        });\n        self.player.addEventListener('ended', e => {\n          self.fire('ended', e);\n        });\n        self.player.addEventListener('loadedmetadata', function () {\n          // get video width and height\n          self.videoWidth = this.videoWidth || 1280;\n          self.videoHeight = this.videoHeight || 720;\n          self.fire('ready');\n\n          // autoplay\n          if (self.options.autoplay) {\n            self.play(self.options.startTime);\n          }\n        });\n        self.player.addEventListener('volumechange', e => {\n          self.getVolume(volume => {\n            self.options.volume = volume;\n          });\n          self.fire('volumechange', e);\n        });\n        self.player.addEventListener('error', e => {\n          self.fire('error', e);\n        });\n      }\n      callback(self.$video);\n    });\n  }\n  init() {\n    const self = this;\n    self.playerID = `VideoWorker-${self.ID}`;\n  }\n  loadAPI() {\n    const self = this;\n    if (YoutubeAPIadded && VimeoAPIadded) {\n      return;\n    }\n    let src = '';\n\n    // load Youtube API\n    if (self.type === 'youtube' && !YoutubeAPIadded) {\n      YoutubeAPIadded = 1;\n      src = 'https://www.youtube.com/iframe_api';\n    }\n\n    // load Vimeo API\n    if (self.type === 'vimeo' && !VimeoAPIadded) {\n      VimeoAPIadded = 1;\n\n      // Useful when Vimeo API added using RequireJS https://github.com/nk-o/video-worker/pull/7\n      if (typeof global$1.Vimeo !== 'undefined') {\n        return;\n      }\n      src = 'https://player.vimeo.com/api/player.js';\n    }\n    if (!src) {\n      return;\n    }\n\n    // add script in head section\n    let tag = document.createElement('script');\n    let head = document.getElementsByTagName('head')[0];\n    tag.src = src;\n    head.appendChild(tag);\n    head = null;\n    tag = null;\n  }\n  onAPIready(callback) {\n    const self = this;\n\n    // Youtube\n    if (self.type === 'youtube') {\n      // Listen for global YT player callback\n      if ((typeof global$1.YT === 'undefined' || global$1.YT.loaded === 0) && !loadingYoutubePlayer) {\n        // Prevents Ready event from being called twice\n        loadingYoutubePlayer = 1;\n\n        // Creates deferred so, other players know when to wait.\n        global$1.onYouTubeIframeAPIReady = function () {\n          global$1.onYouTubeIframeAPIReady = null;\n          loadingYoutubeDefer.resolve('done');\n          callback();\n        };\n      } else if (typeof global$1.YT === 'object' && global$1.YT.loaded === 1) {\n        callback();\n      } else {\n        loadingYoutubeDefer.done(() => {\n          callback();\n        });\n      }\n    }\n\n    // Vimeo\n    if (self.type === 'vimeo') {\n      if (typeof global$1.Vimeo === 'undefined' && !loadingVimeoPlayer) {\n        loadingVimeoPlayer = 1;\n        const vimeoInterval = setInterval(() => {\n          if (typeof global$1.Vimeo !== 'undefined') {\n            clearInterval(vimeoInterval);\n            loadingVimeoDefer.resolve('done');\n            callback();\n          }\n        }, 20);\n      } else if (typeof global$1.Vimeo !== 'undefined') {\n        callback();\n      } else {\n        loadingVimeoDefer.done(() => {\n          callback();\n        });\n      }\n    }\n\n    // Local\n    if (self.type === 'local') {\n      callback();\n    }\n  }\n}\n\nfunction jarallaxVideo$1(jarallax = global$2.jarallax) {\n  if (typeof jarallax === 'undefined') {\n    return;\n  }\n  const Jarallax = jarallax.constructor;\n\n  // append video after when block will be visible.\n  const defOnScroll = Jarallax.prototype.onScroll;\n  Jarallax.prototype.onScroll = function () {\n    const self = this;\n    defOnScroll.apply(self);\n    const isReady = !self.isVideoInserted && self.video && (!self.options.videoLazyLoading || self.isElementInViewport) && !self.options.disableVideo();\n    if (isReady) {\n      self.isVideoInserted = true;\n      self.video.getVideo(video => {\n        const $parent = video.parentNode;\n        self.css(video, {\n          position: self.image.position,\n          top: '0px',\n          left: '0px',\n          right: '0px',\n          bottom: '0px',\n          width: '100%',\n          height: '100%',\n          maxWidth: 'none',\n          maxHeight: 'none',\n          pointerEvents: 'none',\n          transformStyle: 'preserve-3d',\n          backfaceVisibility: 'hidden',\n          margin: 0,\n          zIndex: -1\n        });\n        self.$video = video;\n\n        // add Poster attribute to self-hosted video\n        if (self.video.type === 'local') {\n          if (self.image.src) {\n            self.$video.setAttribute('poster', self.image.src);\n          } else if (self.image.$item && self.image.$item.tagName === 'IMG' && self.image.$item.src) {\n            self.$video.setAttribute('poster', self.image.$item.src);\n          }\n        }\n\n        // add classname to video element\n        if (self.options.videoClass) {\n          self.$video.setAttribute('class', `${self.options.videoClass} ${self.options.videoClass}-${self.video.type}`);\n        }\n\n        // insert video tag\n        self.image.$container.appendChild(video);\n\n        // remove parent video element (created by VideoWorker)\n        $parent.parentNode.removeChild($parent);\n\n        // call onVideoInsert event\n        if (self.options.onVideoInsert) {\n          self.options.onVideoInsert.call(self);\n        }\n      });\n    }\n  };\n\n  // cover video\n  const defCoverImage = Jarallax.prototype.coverImage;\n  Jarallax.prototype.coverImage = function () {\n    const self = this;\n    const imageData = defCoverImage.apply(self);\n    const node = self.image.$item ? self.image.$item.nodeName : false;\n    if (imageData && self.video && node && (node === 'IFRAME' || node === 'VIDEO')) {\n      let h = imageData.image.height;\n      let w = h * self.image.width / self.image.height;\n      let ml = (imageData.container.width - w) / 2;\n      let mt = imageData.image.marginTop;\n      if (imageData.container.width > w) {\n        w = imageData.container.width;\n        h = w * self.image.height / self.image.width;\n        ml = 0;\n        mt += (imageData.image.height - h) / 2;\n      }\n\n      // add video height over than need to hide controls\n      if (node === 'IFRAME') {\n        h += 400;\n        mt -= 200;\n      }\n      self.css(self.$video, {\n        width: `${w}px`,\n        marginLeft: `${ml}px`,\n        height: `${h}px`,\n        marginTop: `${mt}px`\n      });\n    }\n    return imageData;\n  };\n\n  // init video\n  const defInitImg = Jarallax.prototype.initImg;\n  Jarallax.prototype.initImg = function () {\n    const self = this;\n    const defaultResult = defInitImg.apply(self);\n    if (!self.options.videoSrc) {\n      self.options.videoSrc = self.$item.getAttribute('data-jarallax-video') || null;\n    }\n    if (self.options.videoSrc) {\n      self.defaultInitImgResult = defaultResult;\n      return true;\n    }\n    return defaultResult;\n  };\n  const defCanInitParallax = Jarallax.prototype.canInitParallax;\n  Jarallax.prototype.canInitParallax = function () {\n    const self = this;\n    let defaultResult = defCanInitParallax.apply(self);\n    if (!self.options.videoSrc) {\n      return defaultResult;\n    }\n\n    // Init video api\n    const video = new VideoWorker(self.options.videoSrc, {\n      autoplay: true,\n      loop: self.options.videoLoop,\n      showControls: false,\n      accessibilityHidden: true,\n      startTime: self.options.videoStartTime || 0,\n      endTime: self.options.videoEndTime || 0,\n      mute: !self.options.videoVolume,\n      volume: self.options.videoVolume || 0\n    });\n\n    // call onVideoWorkerInit event\n    if (self.options.onVideoWorkerInit) {\n      self.options.onVideoWorkerInit.call(self, video);\n    }\n    function resetDefaultImage() {\n      if (self.image.$default_item) {\n        self.image.$item = self.image.$default_item;\n        self.image.$item.style.display = 'block';\n\n        // set image width and height\n        self.coverImage();\n        self.onScroll();\n      }\n    }\n    if (video.isValid()) {\n      // Force enable parallax.\n      // When the parallax disabled on mobile devices, we still need to display videos.\n      // https://github.com/nk-o/jarallax/issues/159\n      if (this.options.disableParallax()) {\n        defaultResult = true;\n        self.image.position = 'absolute';\n        self.options.type = 'scroll';\n        self.options.speed = 1;\n      }\n\n      // if parallax will not be inited, we can add thumbnail on background.\n      if (!defaultResult) {\n        if (!self.defaultInitImgResult) {\n          video.getImageURL(url => {\n            // save default user styles\n            const curStyle = self.$item.getAttribute('style');\n            if (curStyle) {\n              self.$item.setAttribute('data-jarallax-original-styles', curStyle);\n            }\n\n            // set new background\n            self.css(self.$item, {\n              'background-image': `url(\"${url}\")`,\n              'background-position': 'center',\n              'background-size': 'cover'\n            });\n          });\n        }\n\n        // init video\n      } else {\n        video.on('ready', () => {\n          if (self.options.videoPlayOnlyVisible) {\n            const oldOnScroll = self.onScroll;\n            self.onScroll = function () {\n              oldOnScroll.apply(self);\n              if (!self.videoError && (self.options.videoLoop || !self.options.videoLoop && !self.videoEnded)) {\n                if (self.isVisible()) {\n                  video.play();\n                } else {\n                  video.pause();\n                }\n              }\n            };\n          } else {\n            video.play();\n          }\n        });\n        video.on('started', () => {\n          self.image.$default_item = self.image.$item;\n          self.image.$item = self.$video;\n\n          // set video width and height\n          self.image.width = self.video.videoWidth || 1280;\n          self.image.height = self.video.videoHeight || 720;\n          self.coverImage();\n          self.onScroll();\n\n          // hide image\n          if (self.image.$default_item) {\n            self.image.$default_item.style.display = 'none';\n          }\n        });\n        video.on('ended', () => {\n          self.videoEnded = true;\n          if (!self.options.videoLoop) {\n            // show default image if Loop disabled.\n            resetDefaultImage();\n          }\n        });\n        video.on('error', () => {\n          self.videoError = true;\n\n          // show default image if video loading error.\n          resetDefaultImage();\n        });\n        self.video = video;\n\n        // set image if not exists\n        if (!self.defaultInitImgResult) {\n          // set empty image on self-hosted video if not defined\n          self.image.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';\n          if (video.type !== 'local') {\n            video.getImageURL(url => {\n              self.image.bgImage = `url(\"${url}\")`;\n              self.init();\n            });\n            return false;\n          }\n        }\n      }\n    }\n    return defaultResult;\n  };\n\n  // Destroy video parallax\n  const defDestroy = Jarallax.prototype.destroy;\n  Jarallax.prototype.destroy = function () {\n    const self = this;\n    if (self.image.$default_item) {\n      self.image.$item = self.image.$default_item;\n      delete self.image.$default_item;\n    }\n    defDestroy.apply(self);\n  };\n}\n\nfunction jarallaxElement$1(jarallax = global$2.jarallax) {\n  // eslint-disable-next-line no-console\n  console.warn(\"Jarallax Element extension is DEPRECATED, please, avoid using it. We recommend you look at something like `lax.js` library <https://github.com/alexfoxy/lax.js>. It is much more powerful and has a less code (in cases when you don't want to add parallax backgrounds).\");\n  if (typeof jarallax === 'undefined') {\n    return;\n  }\n  const Jarallax = jarallax.constructor;\n\n  // redefine default methods\n  ['initImg', 'canInitParallax', 'init', 'destroy', 'coverImage', 'isVisible', 'onScroll', 'onResize'].forEach(key => {\n    const def = Jarallax.prototype[key];\n    Jarallax.prototype[key] = function (...args) {\n      const self = this;\n      if (key === 'initImg' && self.$item.getAttribute('data-jarallax-element') !== null) {\n        self.options.type = 'element';\n        self.pureOptions.speed = self.$item.getAttribute('data-jarallax-element') || '100';\n      }\n      if (self.options.type !== 'element') {\n        return def.apply(self, args);\n      }\n      self.pureOptions.threshold = self.$item.getAttribute('data-threshold') || '';\n      switch (key) {\n        case 'init':\n          {\n            const speedArr = `${self.pureOptions.speed}`.split(' ');\n            self.options.speed = self.pureOptions.speed || 0;\n            self.options.speedY = speedArr[0] ? parseFloat(speedArr[0]) : 0;\n            self.options.speedX = speedArr[1] ? parseFloat(speedArr[1]) : 0;\n            const thresholdArr = self.pureOptions.threshold.split(' ');\n            self.options.thresholdY = thresholdArr[0] ? parseFloat(thresholdArr[0]) : null;\n            self.options.thresholdX = thresholdArr[1] ? parseFloat(thresholdArr[1]) : null;\n            def.apply(self, args);\n\n            // restore background image if available.\n            const originalStylesTag = self.$item.getAttribute('data-jarallax-original-styles');\n            if (originalStylesTag) {\n              self.$item.setAttribute('style', originalStylesTag);\n            }\n            return true;\n          }\n        case 'onResize':\n          {\n            const defTransform = self.css(self.$item, 'transform');\n            self.css(self.$item, {\n              transform: ''\n            });\n            const rect = self.$item.getBoundingClientRect();\n            self.itemData = {\n              width: rect.width,\n              height: rect.height,\n              y: rect.top + self.getWindowData().y,\n              x: rect.left\n            };\n            self.css(self.$item, {\n              transform: defTransform\n            });\n            break;\n          }\n        case 'onScroll':\n          {\n            const wnd = self.getWindowData();\n            const centerPercent = (wnd.y + wnd.height / 2 - self.itemData.y - self.itemData.height / 2) / (wnd.height / 2);\n            const moveY = centerPercent * self.options.speedY;\n            const moveX = centerPercent * self.options.speedX;\n            let my = moveY;\n            let mx = moveX;\n            if (self.options.thresholdY !== null && moveY > self.options.thresholdY) my = 0;\n            if (self.options.thresholdX !== null && moveX > self.options.thresholdX) mx = 0;\n            self.css(self.$item, {\n              transform: `translate3d(${mx}px,${my}px,0)`\n            });\n            break;\n          }\n        case 'initImg':\n        case 'isVisible':\n        case 'coverImage':\n          return true;\n        // no default\n      }\n\n      return def.apply(self, args);\n    };\n  });\n}\n\nconst jarallax = jarallax$1;\nconst jarallaxVideo = function jarallaxVideo() {\n  return jarallaxVideo$1(jarallax);\n};\nconst jarallaxElement = function jarallaxElement() {\n  return jarallaxElement$1(jarallax);\n};\n\nexport { jarallax, jarallaxElement, jarallaxVideo };\n//# sourceMappingURL=jarallax.esm.js.map\n","function cards(selector, count) {\r\n    class MenuCard {\r\n        constructor(kind, img, altimg, name, oldPrice, discont, id, parentSelector, ...classes) {\r\n            this.kind = kind;\r\n            this.img = img;\r\n            this.altimg = altimg;\r\n            this.name = name;\r\n            this.oldPrice = oldPrice;\r\n            this.discont = discont;\r\n            this.newPrise = ((oldPrice * (100 - this.discont)) / 100).toFixed(2);\r\n            this.id = id;\r\n            this.parent = document.querySelector(parentSelector);\r\n            this.classes = classes;\r\n        }\r\n\r\n        render() {\r\n            const element = document.createElement('div');\r\n            if (this.classes.length == 0) {\r\n                this.classes = 'products__card';\r\n                element.classList.add(this.classes);\r\n            } else {\r\n                this.classes.forEach((className) => element.classList.add(className));\r\n            }\r\n            element.innerHTML = `\r\n                <div class=\"products__kind\"><span class=\"products__kind-text\">${this.kind}</span></div>\r\n                <a href=\"#\">\r\n                    <img class=\"products__img\" src=${this.img} alt=${this.altimg} />\r\n                    <p class=\"products__name\">${this.name}</p>\r\n                </a>\r\n                <div class=\"line\"></div>\r\n                <div class=\"products__desc\">\r\n                    <div class=\"products__price\">\r\n                        <span class=\"products__old-price\">₽ ${this.oldPrice} РУБ</span>\r\n                        <span class=\"products__new-price\">₽ ${this.newPrise} РУБ</span>\r\n                        <div class=\"rating\">\r\n                            <div class=\"rating__items\">\r\n                                <input id=\"rating-${this.id}__5\" class=\"rating__item\" type=\"radio\" name=\"rating-${this.id}\" value=\"5\" checked />\r\n                                <label for=\"rating-${this.id}__5\" class=\"rating__label\"></label>\r\n                                <input id=\"rating-${this.id}__4\" class=\"rating__item\" type=\"radio\" name=\"rating-${this.id}\" value=\"4\" />\r\n                                <label for=\"rating-${this.id}__4\" class=\"rating__label\"></label>\r\n                                <input id=\"rating-${this.id}__3\" class=\"rating__item\" type=\"radio\" name=\"rating-${this.id}\" value=\"3\" />\r\n                                <label for=\"rating-${this.id}__3\" class=\"rating__label\"></label>\r\n                                <input id=\"rating-${this.id}__2\" class=\"rating__item\" type=\"radio\" name=\"rating-${this.id}\" value=\"2\" />\r\n                                <label for=\"rating-${this.id}__2\" class=\"rating__label\"></label>\r\n                                <input id=\"rating-${this.id}__1\" class=\"rating__item\" type=\"radio\" name=\"rating-${this.id}\" value=\"1\" />\r\n                                <label for=\"rating-${this.id}__1\" class=\"rating__label\"></label>\r\n                            </div>\r\n                        </div>\r\n                    </div>\r\n                </div>\r\n            `;\r\n            this.parent.append(element);\r\n        }\r\n    }\r\n\r\n    const getData = async (url) => {\r\n        const res = await fetch(url);\r\n\r\n        if (!res.ok) {\r\n            throw new Error(`Could not fetch ${url}, status^ ${res.status}`);\r\n        }\r\n\r\n        return await res.json();\r\n    };\r\n\r\n    getData('db.json').then((data) => {\r\n        console.log(data)\r\n        data.menu.forEach(({ kind, img, altimg, name, oldPrice, discont, id }, i) => {\r\n            if (i < count) {\r\n                new MenuCard(kind, img, altimg, name, oldPrice, discont, id, selector).render();\r\n            }\r\n        });\r\n    });\r\n\r\n}\r\n\r\nexport default cards;\r\n","// import \"@babel/polyfill\"\r\n\r\nimport jarallaxjs from './modules/jarallax';\r\nimport cards from './modules/cards';\r\nimport scroll from './modules/scroll';\r\nimport burgerMeny from './modules/burger';\r\n\r\nwindow.addEventListener('DOMContentLoaded', () => {\r\n    jarallaxjs();\r\n    cards('.products__cards1', 6);\r\n    cards('.products__cards2', 3);\r\n    scroll();\r\n    burgerMeny();\r\n});\r\n","import { jarallax } from 'jarallax';\r\n\r\n\r\n\r\nfunction jarallaxjs() {\r\n    jarallax(document.querySelector('.header__body'), {\r\n        speed: 0.2,\r\n    });\r\n    \r\n    jarallax(document.querySelector('.reviews'), {\r\n        speed: 0.2,\r\n    });\r\n}\r\n\r\nexport default jarallaxjs","function scroll() {\r\n\r\n    const anchors = document.querySelectorAll(`a[href*=\"#\"]`)\r\n\r\n    for (let anchor of anchors) {\r\n        anchor.addEventListener('click', (e) => {\r\n            e.preventDefault()\r\n            const blockId = anchor.getAttribute('href')\r\n            document.querySelector('' + blockId).scrollIntoView({\r\n                behavior: 'smooth',\r\n                block: 'start'\r\n            })\r\n        })\r\n    }\r\n}\r\n\r\nexport default scroll","function burgerMeny() {\r\n    const burger = document.querySelector('.burger');\r\n    const nav = document.querySelector('.header__nav');\r\n    const body = document.body;\r\n    const overlay = document.querySelector('.overlay');\r\n    const navItems = document.querySelectorAll('.header__nav-item')\r\n    const basket = document.querySelector('.header__basket')\r\n    const imgMin = document.querySelector('.header__logo-img-min')\r\n\r\n    setInterval(() => {\r\n        let width = window.innerWidth\r\n        if(width > 480 ) {\r\n            burger.style.left = `${width - 60}px`\r\n            basket.style.left = `${width - 140}px`\r\n            imgMin.style.display = 'none'\r\n        } else {\r\n            burger.style.left = `${width - 60}px`\r\n            basket.style.left = `15px`\r\n            imgMin.style.display = 'block'\r\n            imgMin.style.left = `${width/2 - 30}px`\r\n        }\r\n\r\n\r\n    }, 0);\r\n\r\n \r\n\r\n    function openBurger() {\r\n        body.classList.add('stop-scroll');\r\n        burger.classList.add('burger-active');\r\n        nav.classList.add('header__nav-visible');\r\n        overlay.classList.add('overlay--show');\r\n    }\r\n\r\n    function closeBurger() {\r\n        nav.classList.remove('header__nav-visible');\r\n        overlay.classList.remove('overlay--show');\r\n        burger.classList.remove('burger-active');\r\n        body.classList.remove('stop-scroll');\r\n    }\r\n\r\n    burger.addEventListener('click', () => {\r\n        burger.classList.contains('burger-active') ? closeBurger() : openBurger()\r\n        });\r\n\r\n    overlay.addEventListener('click', (e) => {\r\n        if (e.target === overlay) {\r\n            closeBurger()\r\n        }\r\n    })\r\n\r\n    navItems.forEach( (navItem)=> {\r\n        navItem.addEventListener('click', () => {\r\n            closeBurger()\r\n        })\r\n    })\r\n\r\n\r\n}\r\n\r\nexport default burgerMeny;\r\n"],"names":["__webpack_require__","g","globalThis","this","Function","e","window","defaults$1","type","speed","containerClass","imgSrc","imgElement","imgSize","imgPosition","imgRepeat","keepImg","elementInViewport","zIndex","disableParallax","onScroll","onInit","onDestroy","onCoverImage","videoClass","videoSrc","videoStartTime","videoEndTime","videoVolume","videoLoop","videoPlayOnlyVisible","videoLazyLoading","disableVideo","onVideoInsert","onVideoWorkerInit","win$1","self","global$2","navigator","navigator$1","mobileAgent","test","userAgent","wndW","wndH","$deviceHelper","updateWindowHeight","innerWidth","document","documentElement","clientWidth","body","createElement","style","cssText","appendChild","clientHeight","innerHeight","callback","getWindowSize","width","height","addEventListener","readyState","capture","once","passive","jarallaxList","updateParallax","length","forEach","data","k","instance","oldData","isVisible","clientRect","$item","getBoundingClientRect","newData","top","bottom","isResized","isScrolled","onResize","requestAnimationFrame","visibilityObserver","IntersectionObserver","entries","entry","target","jarallax","isElementInViewport","isIntersecting","rootMargin","instanceID","Jarallax","constructor","item","userOptions","defaults","dataOptions","dataset","pureDataOptions","Object","keys","key","lowerCaseOption","substr","toLowerCase","options","extend","pureOptions","Math","min","max","parseFloat","RegExp","disableParallaxRegexp","disableVideoRegexp","elementInVP","Element","image","src","$container","useImgTag","position","initImg","canInitParallax","init","css","el","styles","getComputedStyle","getPropertyValue","out","args","i","extend$1","getWindowData","y","scrollTop","$imgElement","querySelector","Image","cloneNode","$itemParent","parentNode","bgImage","containerStyles","left","overflow","imageStyles","pointerEvents","transformStyle","backfaceVisibility","curStyle","getAttribute","setAttribute","curImgStyle","$parents","elem","parents","parentElement","nodeType","push","getParents","filter","parentTransform","transform","call","observe","destroy","splice","unobserve","originalStylesTag","removeAttribute","originalStylesImgTag","removeChild","coverImage","rect","contH","isScroll","scrollDist","resultH","resultMT","abs","parallaxScrollDistance","marginTop","container","force","contT","beforeTop","beforeTopEnd","afterTop","beforeBottom","beforeBottomEnd","afterBottom","fromViewportCenter","visiblePercent","opacity","scale","positionY","section","jarallax$1","items","HTMLElement","nodeName","len","ret","apply","win","selector","count","MenuCard","kind","img","altimg","name","oldPrice","discont","id","parentSelector","classes","newPrise","toFixed","parent","render","element","classList","add","className","innerHTML","append","async","url","res","fetch","ok","Error","status","json","getData","then","console","log","menu","anchors","querySelectorAll","anchor","preventDefault","blockId","scrollIntoView","behavior","block","burger","nav","overlay","navItems","basket","imgMin","closeBurger","remove","setInterval","display","contains","navItem"],"sourceRoot":""}